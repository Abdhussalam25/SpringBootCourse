

MultiThreading:

Actually single thread each time
however the slicing time is very very low so it is seemed 
to be as continously working with multiple threads at same time.

Dead Lock

Thread A is waiting to complete Thread B
Again Thread B is waiting to complete Thread A

This is known as Dead lock.

synchronized is the one of the 
reason for deadlock is sometimes syhchronicing

Note: inside run we cannot pass any arguments so we have to deal this one carefully

Avoid Nested Locks : This is the main reason for dead lock. Dead Lock mainly happens when we give locks to multiple threads. Avoid giving lock to multiple threads if we already have given to one.
Avoid Unnecessary Locks : We should have lock only those members which are required. Having lock on unnecessarily can lead to dead lock.
Using thread join : Dead lock condition appears when one thread is waiting other to finish. If this condition occurs we can use Thread.join with maximum time you think the execution will take.

If threads are waiting for each other to finish, then the condition is known as Deadlock.
Deadlock condition is a complex condition which occurs only in case of multiple threads.

Thread.sleep() -- > throws IntreptedException

Thread.currentThread().getName()

Thread implements Runnable Interface which contains abstract method run

instead of extending thread if we implement Runnable then it wont be as 
thread and that program will not be a multithreaded application. It will be a normal object oriented program.




class Task implements Runnable

inside public static void main

Task taskRunner  =  new TaskRunner();

Thread t1 =  new Thread(taskRunner);

t1.start();

NOw this will act as a single thread.

Thread t2 = new Thread( new TaskRunner());   // another method of creating thread, 2nd method shorter code

3-rd method using anonyms class

Thread t3 =  new Thread(new Runnable(){

  public void run(){
  
  }

});  //  this will also work as thread.

atomicy -- thread safe

public int getValue(){
    synchronized(this){
    value = value + 1;
    return value;
    }

}

 




